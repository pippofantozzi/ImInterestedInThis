text = """Alan Turing: The Pioneer Behind the Theory
Alan Turing was a British mathematician, logician, and cryptanalyst, widely regarded as the father of theoretical computer science and artificial intelligence. Born in 1912, Turing's contributions during World War II, particularly his role in breaking the Enigma code, were pivotal in the Allied victory. Beyond his wartime achievements, Turing's 1952 paper, "The Chemical Basis of Morphogenesis," introduced the groundbreaking concept that simple chemical reactions could generate complex patterns, akin to those observed in nature. This work laid the foundation for the field of mathematical biology and demonstrated Turing's profound impact on our understanding of natural phenomena and computational theory.

The Essence of Turing's Theory
Turing suggested that the variety of patterns observed in nature could be generated by a simple set of mathematical rules involving two key substances: an activator and an inhibitor. These substances interact within organisms in a way that mirrors predator-prey dynamics, where the activator promotes the production of both substances, and the inhibitor slows it down. This interaction, according to Turing, could lead to the formation of spots, stripes, and other patterns depending on the variables such as the rate of spread of the activator and inhibitor or the total area of the system.

The Activator-Inhibitor Model
Imagine a theoretical organism where the activator and inhibitor are spreading throughout its body. The activator, akin to bunnies in a field, reproduces rapidly, increasing its numbers. Meanwhile, the inhibitor, like foxes preying on the bunnies, grows in response to the activator's population. However, the inhibitor spreads faster, creating a balance that results in distinct patterns. Where the activator dominates, it triggers changes such as pigment production, leading to spots or stripes depending on the interaction dynamics.

Turing Patterns in Nature
Turing's theory beautifully explains how adjusting the interaction rates between the activator and inhibitor can lead to a wide range of patterns. For instance, a slight predominance of the activator in certain areas can result in spots, while a narrow environment might encourage the formation of stripes. Moreover, Turing's rules have been used to simulate patterns that closely resemble those found in nature, such as the splotches on cows or the mosaic patterns on giraffes.

Real-World Applications and Challenges
Despite the elegance of Turing's theory, proving its applicability to real-world biological patterns has been challenging. Some patterns, like the predetermined segments in a developing fruit fly, occur in ways that don't align with Turing's model. However, there have been discoveries of Turing-like systems in nature, such as the interaction between proteins in developing mice that produce stripey ridges or digit formations, suggesting that Turing's ideas do have a place in the natural world.

Turing's Legacy and Biological Exploration
Turing's theory has not only provided a mathematical framework for understanding natural patterns but has also inspired biologists to search for evidence of these principles in living organisms. This ongoing exploration brings us closer to understanding the mechanisms behind the formation of patterns in nature, from the cheetah's spots to the stripes on a fish.

Inspiration for Modern AI and Image Generation
The concept of diffusion, as proposed by Turing, wherein two substances interact according to simple rules to form complex patterns, bears a conceptual resemblance to the mechanisms behind modern image generation in artificial intelligence, including technologies like stable diffusion. Stable diffusion models, which are at the forefront of AI-driven image creation, operate on principles that echo Turing's ideasâ€”utilizing layers of interaction (akin to the activator-inhibitor dynamics) to generate intricate and diverse outputs from basic inputs. While Turing's work did not directly address digital image generation, the underlying theory of generating complexity from simplicity parallels the processes used in AI today. This conceptual lineage highlights how Turing's insights into pattern formation have indirectly inspired advancements in artificial intelligence, enabling machines to create images that mimic the complexity and beauty of the natural world.

Conclusion
Alan Turing's theory offers a fascinating insight into the complexity of nature's designs, suggesting that the diversity of patterns we observe can be explained through simple mathematical rules. While not all patterns in nature fit neatly into Turing's model, the theory has significantly influenced the study of biological patterns, encouraging scientists to explore the natural world through a mathematical lens. As research continues, Turing's legacy remains a testament to the power of interdisciplinary inquiry, bridging the gap between mathematics and biology in the quest to unravel the mysteries of nature's patterns."""

def process_text(input_text=text):
    lines = input_text.split('\n')
    subheaders = []
    texts = []
    current_text = ""
    expecting_subheader = True  # Start by expecting a subheader

    for line in lines:
        # Check for subheader
        if expecting_subheader:
            if line.strip():  # If the line is not empty
                subheaders.append(line.strip())
                expecting_subheader = False  # Next, we expect text
                if current_text:  # If there's accumulated text, start a new one
                    texts.append(current_text)
                    current_text = ""
            continue

        # If we're not expecting a subheader, check if we're at the end of a text section
        if line.strip() == "" and not expecting_subheader:  # Check for an empty line indicating end of a text
            expecting_subheader = True  # Next, expect a subheader
        else:
            current_text += line + "\n"  # Add line to current text

    # After the loop, add the last text section if it exists
    if current_text.strip():
        texts.append(current_text.strip())

    return subheaders, texts

# Your text goes here
subheaders, texts = process_text()
print(subheaders)

images = ["images\TuringPatterns\lanturing.jpg","images\TuringPatterns\equation.png","images\TuringPatterns\unnies.JPG","images\TuringPatterns\patterns.webp",
          "Nothing","images\TuringPatterns\morphogenesis.jpeg","images\TuringPatterns\stablediffusion.jpg","Nothing"]


def get_images(images = images):
    return images

from scipy.ndimage import convolve, generate_binary_structure
import numpy as np

def simulate_turing_patterns(size=100, steps=5000, Du=0.16, Dv=0.08, feed_rate=0.035, kill_rate=0.06):
    # Initialize activator (u) and inhibitor (v) grids
    u = np.ones((size, size))
    v = np.zeros((size, size))

    # Introduce a disturbance in the center
    u[size//2-5:size//2+5, size//2-5:size//2+5] = 0.50
    v[size//2-5:size//2+5, size//2-5:size//2+5] = 0.25

    # Laplacian kernel for diffusion
    laplacian_kernel = generate_binary_structure(2, 1)
    laplacian_kernel = np.array(laplacian_kernel, dtype=float)
    laplacian_kernel[1][1] = -laplacian_kernel.sum() + 1

    for _ in range(steps):
        # Convolve with laplacian kernel to compute diffusion
        u_diffused = convolve(u, laplacian_kernel, mode='reflect')
        v_diffused = convolve(v, laplacian_kernel, mode='reflect')

        # Reaction-diffusion equations
        uvv = u*v*v
        u += Du * u_diffused - uvv + feed_rate * (1 - u)
        v += Dv * v_diffused + uvv - (feed_rate + kill_rate) * v

    return u, v